{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pax Technical Wiki","text":"<p>The landing page for developers. Documentation should be reviewed and versioned control. Oh, and this is free!</p>"},{"location":"#navigation","title":"Navigation","text":"<p>You can either use the search bar or use the navigation bar to find your documents. At worse, you can always grep the repository.</p>"},{"location":"#usage","title":"Usage","text":"<ul> <li>The mkdocs website is very informative and a good starting place if you have never   used <code>mkdocs</code></li> <li>To see the good looks, we use the material theme and you can look at   its docs for any special UI components</li> <li>To add new pages, follow the add a new document how-to</li> </ul>"},{"location":"#run-locally","title":"Run locally","text":"<p>Ensure you have installed:</p> <pre><code>pip install mkdocs mkdocs-material\n</code></pre> <p>Then you can run a local server</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"explain/the-different-render-blueprints/","title":"Explain: the different Render blueprints","text":""},{"location":"explain/the-different-render-blueprints/#context","title":"Context","text":"<p>If you look at the Render blueprints tab, you'll see two styles of blueprints:</p> <ul> <li><code>deployment-*</code> (like <code>deployment-prod</code>)</li> <li><code>repo-*</code> (like <code>repo-be-app</code>)</li> </ul> <p>At first glance, it isn't obvious why we have so many blueprints and when to adjust one or the other.</p>"},{"location":"explain/the-different-render-blueprints/#different-blueprints-for-different-sdlcs","title":"Different blueprints for different SDLCs","text":"<p>The different blueprints is to support different sdlc pipelines for different components. The <code>deployment</code> blueprint is a typical release manifest. All of our production runtimes are declared in a single place and peer-reviewed with the proper scrutiny. Additionally, we don't need to modify many different places to release or rollback.</p> <p>For the repo-specific blueprints, we similarly want to keep code changes and nonprod deployments in a single merge. Consider a situation where you want to add a new feature to your app that requires new external dependencies (like a database). When you merge to your repo, you don't want to take down dev, so you would modify your source code and blueprint in the same changeset.</p> <p>Finally, render does support the ability to do <code>preview environments</code>. In other words, a branch of your repo could generate a super scaled down version of this app deployment, but this depends on having configured render.yml which we wouldn't want to support in the production manifest.</p> <p>You might be wondering if we could use the github triggered autodeployment feature as well. With the repo-aligned blueprints this is possible. However, we avoid it for 2 reasons:</p> <ul> <li>we like building our own images and being able to pull them for local development and debugging</li> <li>we want to save on pipeline time to keep ourselves on the free tier for as long as possible</li> </ul>"},{"location":"explain/the-documentation-structure/","title":"Explain: The documentation structure","text":"<p>The documentation structure of the technical docs is inspired from the grand unified theory of documentation.</p> <p>Basically, we categorize all documents into one of four types and then tailor or prose to fit that mold. From experience the majority of docs fall into one of these 4 categories and we drive clarity for the reader by letting them know what to expect in a document with a certain label.</p>"},{"location":"explain/the-terraform-cloud-sdlc/","title":"Explain: the Terraform Cloud sdlc","text":""},{"location":"explain/the-terraform-cloud-sdlc/#context","title":"Context","text":"<p>Unlike a normal code changeset where we merge a pull request and call it a day, our Terraform sdlc has a couple more manual steps to ensure we don't delete real resources.</p>"},{"location":"explain/the-terraform-cloud-sdlc/#github-integration","title":"GitHub Integration","text":"<ol> <li>When you create a pull request to a TFC (Terraform Cloud) aware repo, you'll see a link to    a speculative run.</li> <li>When you merge a pull request, TFC will run another apply run that does a plan and awaits for you to review and    hit <code>apply</code>.</li> </ol> <p>TFC runs are linked to the pull request. Otherwise, you can navigate to Paxfinancial TFC directly.</p>"},{"location":"explain/the-terraform-cloud-sdlc/#speculative-runs","title":"Speculative runs","text":"<p>Terraform is all about declaring what you desire in the world, Terraform doing a reconciliation from its known state and the actual world, and then taking actions to rectify the possible differences.</p> <p>Speculative runs allow you to see before any changes actually happen what Terraform intends to do your environment. This is basically your way to review the code changes for correctness. If you see something tagged for deletion that you don't expect... then don't merge!</p> <p>Underneath the hood, speculative runs are basically TFC running <code>terraform plan</code>.</p>"},{"location":"explain/the-terraform-cloud-sdlc/#apply-runs","title":"Apply runs","text":"<p>Always off of the trunk of your repo, the apply run is TFE running <code>terraform apply</code>.</p>"},{"location":"how-to/access-postgres/","title":"How to: Access Postgresl","text":"<p>In a breakglass situation, you may want to run sql queries against your database directly.</p>"},{"location":"how-to/access-postgres/#steps","title":"Steps","text":"<ol> <li>ensure you have a pg client available<ol> <li>download pgadmin</li> <li><code>brew search postgres</code></li> </ol> </li> <li>Open up the whitelist in Render in the database info tab<ol> <li>Example: dev database</li> <li>Under Access Control add source</li> </ol> </li> <li>Then you can pull your connection details from the PSQL Command text box</li> <li>Connect through your preferred client</li> </ol>"},{"location":"how-to/add-a-new-documentation-page/","title":"How to: Add a new document","text":"<p>It needs to be easy to add new files.</p>"},{"location":"how-to/add-a-new-documentation-page/#steps","title":"Steps","text":"<p>The instructions differ a little bit depending if the current navigation structure is good enough for you. It is expected that we'll add new groups and possibly reorder documents as needed as the knowledge base grows.</p>"},{"location":"how-to/add-a-new-documentation-page/#add-hidden-files","title":"Add hidden files","text":"<p>This is the simplest approach when you just want to add a file that isn't present in the navigation bar but you can search through hyperlinks in other documents. You'll probably use this for seldom used documents that you would only look at in the context of another document, i.e project design documents under a project folder.</p> <p>This is simplest because you can do whatever you want as long as you write markdown files under the <code>docs/</code> folder. The file is even searchable in our search bar!</p>"},{"location":"how-to/add-a-new-documentation-page/#adding-to-an-existing-foldergroup","title":"Adding to an existing folder/group","text":"<p>First you need to find your folder. All documentation lives under the <code>docs/</code> folder. You can find the navigation structure through the <code>mkdocs.yml</code>.</p> <p>Second, write your markdown file. Note, you can take advantage of our material theme's components.</p> <p>Lastly, <code>git commit -am 'your changes' &amp;&amp; git push</code>!</p>"},{"location":"how-to/add-a-new-documentation-page/#adding-a-new-group","title":"Adding a new group","text":"<p>First, navigate to the <code>mkdocs.yml</code> file and adjust the <code>nav</code> key as needed. Then you can follow add to existing folder.</p>"},{"location":"how-to/add-new-secret-groups/","title":"How to: Add a new secret group","text":"<p>Secrets are mastered in Render.</p>"},{"location":"how-to/add-new-secret-groups/#steps","title":"Steps","text":"<ol> <li>Go to environment groups</li> <li>Add a new group as needed<ol> <li>Make it environment aware (dev/prod/...)</li> </ol> </li> <li>Add k/v secrets as needed</li> <li>With your group name, add to your desired blueprint under <code>envVars</code> </li> <li><code>fromGroup: &lt;new group name&gt;</code></li> </ol>"},{"location":"how-to/release-to-production/","title":"How to: Release to production","text":"<p>Production releases on our PaaS Render</p>"},{"location":"how-to/release-to-production/#steps","title":"Steps","text":"<ol> <li>For the components you want to upgrade, <code>git tag</code> the point in history you want to release.<ol> <li>All release tags must start with <code>v</code> in order for our pipeline to pick it up, i.e <code>v1.0.2</code>.</li> </ol> </li> <li>Wait for the GitHub action to complete, for example BE actions</li> <li>Navivate to the corresponding GitHub package for your image, for    example BE packages<ol> <li>Make sure your new tag is present!</li> </ol> </li> <li>Go to the <code>render-blueprints</code> repository and update the <code>image.url</code> value with the new tag</li> <li>Push up your change and monitor in the dashboard</li> </ol>"},{"location":"reference/on-the-render-setup/","title":"Reference: On the Render setup","text":"Info Value Comment Render Dashboard https://dashboard.render.com/ View deployments across environments Credit Card Pax Busines Card (Texas) Contact Email julien.homble@pax-fin.com Linked to personal login until we create a team Registry Credentials <code>paxfin-ghcr</code> Tied to a classic token for jjhomble, this allows pull images from GitHub container registry"},{"location":"reference/on-the-terraform-cloud-setup/","title":"Reference: On the Terraform Cloud setup","text":"Info Value Comment Terraform Cloud URL https://app.terraform.io/ Free tier SaaS Organization paxfinancial Contact Email julien.homble@pax-fin.com Tied to personal email until we think about teams Workspace: terraformer TFC Workspace GitHub"}]}